name: Deploy Xray Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: >-
          GitHub environment that contains the deployment secrets.
        required: true
        type: environment
      limit:
        description: >-
          Optional Ansible limit pattern (host or group) to scope the deployment.
        required: false
        default: ""
  workflow_call:
    inputs:
      environment:
        description: >-
          GitHub environment that contains the deployment secrets.
        required: true
        type: string
      limit:
        description: >-
          Optional Ansible limit pattern (host or group) to scope the deployment.
        required: false
        type: string
        default: ""

concurrency:
  group: deploy-${{ inputs.environment || github.event.inputs.environment || 'unspecified' }}
  cancel-in-progress: false

jobs:
  validate-environment:
    name: Validate deployment environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.ensure.outputs.environment }}
    steps:
      - name: Ensure environment exists
        id: ensure
        env:
          REQUESTED_ENVIRONMENT: ${{ inputs.environment || '' }}
          FALLBACK_ENVIRONMENT: ${{ github.event.inputs.environment || '' }}
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail

          REQUESTED_ENVIRONMENT="${REQUESTED_ENVIRONMENT:-}"
          if [ -z "$REQUESTED_ENVIRONMENT" ]; then
            REQUESTED_ENVIRONMENT="${FALLBACK_ENVIRONMENT:-}"
          fi

          if [ -z "$REQUESTED_ENVIRONMENT" ]; then
            echo "::error::No environment provided. Choose an environment before running the workflow."
            exit 1
          fi

          api_url="https://api.github.com/repos/${REPOSITORY}/environments/${REQUESTED_ENVIRONMENT}"
          status=$(curl -sS \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -o "$RUNNER_TEMP/environment.json" \
            -w '%{http_code}' \
            "$api_url")

          if [ "$status" -ne 200 ]; then
            if [ -f "$RUNNER_TEMP/environment.json" ]; then
              echo "::debug::$(cat "$RUNNER_TEMP/environment.json")"
            fi
            echo "::error::Environment '${REQUESTED_ENVIRONMENT}' was not found in repository '${REPOSITORY}'."
            exit 1
          fi

          echo "environment=${REQUESTED_ENVIRONMENT}" >> "$GITHUB_OUTPUT"

  deploy:
    name: Run Ansible deployment
    runs-on: ubuntu-latest
    needs: validate-environment
    environment: ${{ needs.validate-environment.outputs.environment }}
    env:
      ANSIBLE_HOST_KEY_CHECKING: "false"
      XRAY_UUID: ${{ secrets.XRAY_UUID }}
      XRAY_SHORT_IDS: ${{ secrets.XRAY_SHORT_IDS }}
      XRAY_PRIVATE_KEY: ${{ secrets.XRAY_PRIVATE_KEY }}
      XRAY_PUBLIC_KEY: ${{ secrets.XRAY_PUBLIC_KEY }}
      XRAY_SNI: ${{ secrets.XRAY_SNI != '' && secrets.XRAY_SNI || vars.XRAY_DECOY_SNI != '' && vars.XRAY_DECOY_SNI || '' }}
      HOST_SSH_PRIVATE_KEY: ${{ secrets.HOST_SSH_PRIVATE_KEY }}
      HOST_SSH_PUBLIC_KEY: ${{ secrets.HOST_SSH_PUBLIC_KEY }}
      REMOTE_SERVER_IP_ADDRESS: ${{ vars.REMOTE_SERVER_IP_ADDRESS }}
      REMOTE_SERVER_USER: ${{ vars.REMOTE_SERVER_USER }}
      REMOTE_SERVER_PORT: ${{ vars.REMOTE_SERVER_PORT }}
      ANSIBLE_INVENTORY_PATH: ansible/inventory.yml
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible-core~=2.16

      - name: Mask sensitive variables
        shell: bash
        run: |
          set -euo pipefail
          echo "::add-mask::${XRAY_UUID}"
          echo "::add-mask::${XRAY_SHORT_IDS}"
          echo "::add-mask::${XRAY_PRIVATE_KEY}"
          echo "::add-mask::${XRAY_PUBLIC_KEY}"
          echo "::add-mask::${HOST_SSH_PRIVATE_KEY}"
          if [ -n "${HOST_SSH_PUBLIC_KEY:-}" ]; then
            echo "::add-mask::${HOST_SSH_PUBLIC_KEY}"
          fi

      - name: Configure SSH key
        if: env.HOST_SSH_PRIVATE_KEY != ''
        shell: bash
        run: |
          set -euo pipefail
          install -m 0700 -d "$HOME/.ssh"
          printf '%s\n' "${HOST_SSH_PRIVATE_KEY}" > "$HOME/.ssh/id_ed25519"
          chmod 600 "$HOME/.ssh/id_ed25519"
          if [ -n "${HOST_SSH_PUBLIC_KEY:-}" ]; then
            printf '%s\n' "${HOST_SSH_PUBLIC_KEY}" > "$HOME/.ssh/id_ed25519.pub"
            chmod 644 "$HOME/.ssh/id_ed25519.pub"
          fi
          cat <<'CONFIG' > "$HOME/.ssh/config"
          Host *
            IdentityFile ~/.ssh/id_ed25519
            IdentitiesOnly yes
          CONFIG

      - name: Display Ansible version
        run: ansible --version

      - name: Run Ansible playbook
        env:
          LIMIT: ${{ inputs.limit || github.event.inputs.limit || '' }}
        shell: bash
        run: |
          set -euo pipefail

          LIMIT_ARGS=()
          if [ -n "$LIMIT" ]; then
            LIMIT_ARGS+=("--limit" "$LIMIT")
          fi

          INVENTORY_ARGS=()
          HOST_IP="${REMOTE_SERVER_IP_ADDRESS:-}"
          HOST_USER="${REMOTE_SERVER_USER:-}"
          HOST_PORT="${REMOTE_SERVER_PORT:-}"

          if [ -n "$HOST_IP" ] && [ -n "$HOST_USER" ]; then
            INLINE_INVENTORY="$RUNNER_TEMP/inline-xray-inventory.ini"
            {
              echo "[xray_servers]"
              HOST_LINE="remote ansible_host=${HOST_IP} ansible_user=${HOST_USER}"
              if [ -n "$HOST_PORT" ]; then
                HOST_LINE="$HOST_LINE ansible_port=${HOST_PORT}"
              fi
              echo "$HOST_LINE"
            } > "$INLINE_INVENTORY"
            INVENTORY_ARGS+=("--inventory" "$INLINE_INVENTORY")
          else
            INVENTORY_ARGS+=("--inventory" "$ANSIBLE_INVENTORY_PATH")
          fi

          CMD=(ansible-playbook)
          CMD+=("${INVENTORY_ARGS[@]}")
          if [ "${#LIMIT_ARGS[@]}" -gt 0 ]; then
            CMD+=("${LIMIT_ARGS[@]}")
          fi
          CMD+=(ansible/site.yml)

          "${CMD[@]}"

      - name: Display client connection details
        if: success()
        shell: bash
        env:
          XRAY_DOMAIN: ${{ env.XRAY_SNI }}
        run: |
          set -euo pipefail

          DOMAIN="${XRAY_DOMAIN:-}"
          if [ -z "$DOMAIN" ]; then
            if [ -n "${REMOTE_SERVER_IP_ADDRESS:-}" ]; then
              DOMAIN="${REMOTE_SERVER_IP_ADDRESS}"
              echo "::notice::No XRAY_SNI secret detected; using remote server IP ${DOMAIN}."
            else
              echo "::warning::No XRAY_SNI secret or remote server IP detected; using placeholder example.com."
              DOMAIN="example.com"
            fi
          fi

          UUID="${XRAY_UUID:-}"
          if [ -z "$UUID" ]; then
            echo "::error::XRAY_UUID secret is required to render client connection details."
            exit 1
          fi

          PORT="${XRAY_PORT:-}"
          if [ -z "$PORT" ]; then
            PORT=443
          fi

          SHORT_ID=""
          if [ -n "${XRAY_SHORT_IDS:-}" ]; then
            IFS=',' read -r first _ <<< "${XRAY_SHORT_IDS}"
            SHORT_ID="$(printf '%s' "${first}" | xargs || true)"
          fi

          if [ -n "$SHORT_ID" ]; then
            SID_PARAM="&sid=$(python -c "import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1]))" "$SHORT_ID")"
          else
            SID_PARAM=""
            echo "::warning::No short IDs detected; skipping sid parameter in generated URIs."
          fi

          PUBLIC_KEY="${XRAY_PUBLIC_KEY:-}"
          if [ -n "$PUBLIC_KEY" ]; then
            PBK_PARAM="&pbk=$(python -c "import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1]))" "$PUBLIC_KEY")"
          else
            PBK_PARAM=""
            echo "::warning::XRAY_PUBLIC_KEY secret is empty; pbk parameter will be omitted."
          fi

          FLOW="xtls-rprx-vision"
          ALPN_ENCODED="h2%2Chttp%2F1.1"
          CLIENT_NAME="Less Vision Reality (${DOMAIN})"
          export CLIENT_NAME
          NAME_ENCODED=$(python -c "import os, urllib.parse; print(urllib.parse.quote(os.environ['CLIENT_NAME']))")

          SHADOWROCKET_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}${PBK_PARAM}${SID_PARAM}#${NAME_ENCODED}"
          CLASH_META_URI="vless://${UUID}@${DOMAIN}:${PORT}?encryption=none&security=tls&type=tcp&flow=${FLOW}&sni=${DOMAIN}&alpn=${ALPN_ENCODED}&fp=chrome${PBK_PARAM}${SID_PARAM}#${NAME_ENCODED}"

          CLASH_VERGE_LINES=()
          CLASH_VERGE_LINES+=("- name: Less Vision Reality (${DOMAIN})")
          CLASH_VERGE_LINES+=("  type: vless")
          CLASH_VERGE_LINES+=("  server: ${DOMAIN}")
          CLASH_VERGE_LINES+=("  port: ${PORT}")
          CLASH_VERGE_LINES+=("  uuid: ${UUID}")
          CLASH_VERGE_LINES+=("  cipher: none")
          CLASH_VERGE_LINES+=("  tls: true")
          CLASH_VERGE_LINES+=("  network: tcp")
          CLASH_VERGE_LINES+=("  flow: ${FLOW}")
          CLASH_VERGE_LINES+=("  udp: true")
          CLASH_VERGE_LINES+=("  servername: ${DOMAIN}")
          CLASH_VERGE_LINES+=("  alpn:")
          CLASH_VERGE_LINES+=("    - h2")
          CLASH_VERGE_LINES+=("    - http/1.1")

          if [ -n "$PUBLIC_KEY" ] || [ -n "$SHORT_ID" ]; then
            CLASH_VERGE_LINES+=("  reality-opts:")
            if [ -n "$PUBLIC_KEY" ]; then
              CLASH_VERGE_LINES+=("    public-key: ${PUBLIC_KEY}")
            fi
            if [ -n "$SHORT_ID" ]; then
              CLASH_VERGE_LINES+=("    short-id: ${SHORT_ID}")
            fi
          fi

          CLASH_VERGE_LINES+=("  client-fingerprint: chrome")
          CLASH_VERGE_BLOCK="$(printf '%s\n' "${CLASH_VERGE_LINES[@]}")"


          if ! command -v qrencode >/dev/null 2>&1; then
            echo "Installing qrencode for QR code output..."
            sudo apt-get update
            sudo apt-get install -y qrencode
          fi

          print_qr_section() {
            local label="$1"
            local uri="$2"

            printf '\n%s\n' "$label"
            printf '%s\n\n' "$(printf '%*s' "${#label}" '' | tr ' ' '-')"
            printf '%s\n\n' "$uri"

            if command -v qrencode >/dev/null 2>&1; then
              qrencode -t ansiutf8 <<< "$uri"
              printf '\n'
            else
              echo "::warning::qrencode is not available; skipping QR code generation for $label."
            fi
          }

          printf '%s\n' \
            "============================================================" \
            "Client Configuration Summary" \
            "============================================================" \
            "" \
            "Shadowrocket (iOS)" \
            "------------------" \
            "${SHADOWROCKET_URI}" \
            "" \
            "Clash Meta (Android)" \
            "--------------------" \
            "${CLASH_META_URI}" \
            "" \
            "Clash Verge (Desktop)" \
            "---------------------" \
            "${CLASH_VERGE_BLOCK}"

          print_qr_section "Shadowrocket (iOS) QR" "$SHADOWROCKET_URI"
          print_qr_section "Clash Meta (Android) QR" "$CLASH_META_URI"
          print_qr_section "Clash Verge (Desktop) QR" "$CLASH_META_URI"
